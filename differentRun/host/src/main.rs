// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
// use methods::{
//     HELLO_GUEST_ELF, HELLO_GUEST_ID
// };
use std::env;
// use std::fs::File;
use std::fs::{self, File, OpenOptions,metadata};
use std::io::{self, Read};
use risc0_zkvm::{default_prover, ExecutorEnv};
use anyhow::Result;
use sp1_sdk::{ProverClient, SP1Stdin};
use risc0_zkvm::ExecutorImpl;
use std::path::Path;
use std::hash::{Hasher, SipHasher};
use chrono::Local;
use csv::{WriterBuilder, Writer};

// fn prove(){
//     // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
//     tracing_subscriber::fmt()
//         .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
//         .init();

//     // An executor environment describes the configurations for the zkVM
//     // including program inputs.
//     // A default ExecutorEnv can be created like so:
//     // `let env = ExecutorEnv::builder().build().unwrap();`
//     // However, this `env` does not have any inputs.
//     //
//     // To add guest input to the executor environment, use
//     // ExecutorEnvBuilder::write().
//     // To access this method, you'll need to use ExecutorEnv::builder(), which
//     // creates an ExecutorEnvBuilder. When you're done adding input, call
//     // ExecutorEnvBuilder::build().

//     // For example:
//     let input: u32 = 15 * u32::pow(2, 27) + 1;
//     let env = ExecutorEnv::builder()
//         .write(&input)
//         .unwrap()
//         .build()
//         .unwrap();

//     // Obtain the default prover.
//     let prover = default_prover();

//     // Proof information by proving the specified ELF binary.
//     // This struct contains the receipt along with statistics about execution of the guest
//     let prove_info = prover
//         .prove(env, HELLO_GUEST_ELF)
//         .unwrap();

//     // extract the receipt.
//     let receipt = prove_info.receipt;

//     // TODO: Implement code for retrieving receipt journal here.

//     // For example:
//     let _output: u32 = receipt.journal.decode().unwrap();

//     println!("Hello, world! I generated a proof of guest execution! {} is a public output from journal ", _output);

//     // The receipt was verified at the end of proving, but the below code is an
//     // example of how someone else could verify this receipt.
//     receipt
//         .verify(HELLO_GUEST_ID)
//         .unwrap();
// }

fn load_file(file_path: &str) -> io::Result<Vec<u8>> {
    let mut file = File::open(file_path)?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer)?;
    Ok(buffer)
}

fn risc0_execute(file_path: &str) -> Option<String> {
    // println!("start execute·····");

    let env = ExecutorEnv::builder()
        .build()
        .unwrap();  
    
    let file_contents = match load_file(file_path) {
        Ok(contents) => contents,
        Err(e) => {
            eprintln!("Error loading risc0 file: {}", e);
            return None;
        }
    };

    let mut exec = ExecutorImpl::from_elf(env, &file_contents).unwrap();
    let output = match exec.run() {
        Ok(output) => output,
        Err(e) => {
            eprintln!("Execution risc0 file failed: {}", e);
            return None;
        }
    };
    match output.journal {
        Some(journal) => {
            // println!("original output: {:?}", journal);
            if !journal.bytes.is_empty() {
                let decoded_output: String = journal.decode().unwrap();
                let trimmed_output = decoded_output.trim().to_string();
                // println!("trimmed decoded output: {:?}", trimmed_output);
                return Some(trimmed_output);
            }
        }
        None => {}
    }

    // println!("end execute·····");
    None  // 如果没有解码输出，返回 None
}

fn sp1_execute(file_path: &str)-> Option<String> {
    sp1_sdk::utils::setup_logger();
    let client: ProverClient = ProverClient::new();

    let file_contents = match load_file(file_path) {
        Ok(contents) => contents,
        Err(e) => {
            eprintln!("Error loading sp1 file: {}", e);
            return None;
        }
    };

    // Setup the inputs.
    let mut stdin: SP1Stdin = SP1Stdin::new();
    let (output, report) = match client.execute(&file_contents, stdin).run() {
        Ok((output, report)) => (output, report),  // 执行成功
        Err(e) => {
            eprintln!("Execution sp1 file failed: {}", e);
            return None;
        }
    };
    let temp = output.as_slice();
    let result_str = String::from_utf8_lossy(temp)
    .trim()
    .chars()
    .filter(|&ch| ch != '\0' && ch != '\u{8}')  // 过滤掉 '\0' 和 '\b'
    .collect::<String>();
    Some(result_str) 

}


fn compute_file_hash(file_path: &str) -> String {
    let mut hasher = SipHasher::new();
    let mut file = File::open(file_path).expect("Failed to open file");

    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer).expect("Failed to read file");
    
    hasher.write(&buffer);
    let hash = hasher.finish();
    
    // Convert hash to a hexadecimal string
    format!("{:x}", hash)
}

fn output_difference(target_base_dir: &str,risc0_file_path: &str,sp1_file_path: &str,risc0_content:&str,sp1_content:&str){
        // Step 1: Compute hash of risc0_file_path
        let risc0_hash = compute_file_hash(risc0_file_path);
        println!("Hash of risc0 file: {}", risc0_hash);

        // Step 2: Create target directory (target_base_dir + risc0_hash)
        let target_dir = format!("{}/program", target_base_dir);
        if !Path::new(&target_dir).exists() {
            fs::create_dir_all(&target_dir).expect("Failed to create target directory.");
        }

        // Step 3: Copy the risc0_file_path and sp1_file_path to the target directory
        let current_time = Local::now().format("%Y%m%d%H%M%S").to_string();
        let risc0_name=format!("risc0_{}_{}.rs", risc0_hash,current_time);
        let target_risc0_path = format!("{}/{}", target_dir, risc0_name);
        let sp1_name=format!("sp1_{}_{}.rs", risc0_hash,current_time);
        let target_sp1_path = format!("{}/{}", target_dir, sp1_name);

        // Copy risc0 file
        fs::copy(risc0_file_path, &target_risc0_path).expect("Failed to copy risc0 file.");
        println!("risc0 file copied to: {}", target_risc0_path);

        // Copy sp1 file
        fs::copy(sp1_file_path, &target_sp1_path).expect("Failed to copy sp1 file.");
        println!("sp1 file copied to: {}", target_sp1_path);


        // Step 4: Create a CSV file and write the data
        let csv_path = format!("{}/difference.csv", target_base_dir);
        // Open the CSV file in append mode
        let file_exists = metadata(&csv_path).is_ok(); // Check if file exists
        let file = OpenOptions::new()
            .create(true)
            .append(true)
            .write(true)
            .open(&csv_path)
            .expect("Failed to open or create CSV file");

        let mut wtr = WriterBuilder::new().from_writer(file);

        // If file is empty, write the header
        if !file_exists || metadata(&csv_path).unwrap().len() == 0 {
            wtr.write_record(&["risc0_file", "sp1_file", "risc0_content", "sp1_content"])
                .expect("Failed to write CSV header");
        }

        // Write the row with file paths and content
        wtr.write_record(&[
            &risc0_name,
            &sp1_name,
            risc0_content,
            sp1_content,
        ])
        .expect("Failed to write CSV record");
}

fn diffExecute(risc0_file_path: &str,sp1_file_path: &str,output_dir: &str){
    let risc0_result=risc0_execute(risc0_file_path);
    let risc0_str = risc0_result.clone().unwrap_or("No result".to_string());
    println!("risc0_result: {}", risc0_str);

    let sp1_result=sp1_execute(sp1_file_path);
    let sp1_str = sp1_result.clone().unwrap_or("No result".to_string());
    println!("sp1_result: {}", sp1_str);

    // for ch in sp1_str.chars() {
    //     println!("{}", ch);
    // }

    if risc0_str == sp1_str {
        println!("The results are the same.");
    } else {
        output_difference(output_dir,risc0_file_path,sp1_file_path,&risc0_str,&sp1_str);
        println!("The results are different.");
    }
}



fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 4 {
        eprintln!("Usage: {} <mode>, <risc0_file_path>, <sp1_file_path>, <output_dir>", args[0]);
        std::process::exit(1);
    }
    let mode = &args[1];
    let risc0_file_path = &args[2];
    let sp1_file_path = &args[3];
    let output_dir = &args[4];
    
    if mode=="execute"{
        diffExecute(risc0_file_path,sp1_file_path,output_dir)
    }
    else{
        // prove(file_path)
    }
    
    
}
