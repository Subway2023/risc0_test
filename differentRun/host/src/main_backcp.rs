// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
// use methods::{
//     HELLO_GUEST_ELF, HELLO_GUEST_ID
// };
use std::env;
use std::fs::File;
use std::io::{self, Read};
use risc0_zkvm::{default_prover, ExecutorEnv};
use anyhow::Result;

use risc0_zkvm::ExecutorImpl;

// fn prove(){
//     // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
//     tracing_subscriber::fmt()
//         .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
//         .init();

//     // An executor environment describes the configurations for the zkVM
//     // including program inputs.
//     // A default ExecutorEnv can be created like so:
//     // `let env = ExecutorEnv::builder().build().unwrap();`
//     // However, this `env` does not have any inputs.
//     //
//     // To add guest input to the executor environment, use
//     // ExecutorEnvBuilder::write().
//     // To access this method, you'll need to use ExecutorEnv::builder(), which
//     // creates an ExecutorEnvBuilder. When you're done adding input, call
//     // ExecutorEnvBuilder::build().

//     // For example:
//     let input: u32 = 15 * u32::pow(2, 27) + 1;
//     let env = ExecutorEnv::builder()
//         .write(&input)
//         .unwrap()
//         .build()
//         .unwrap();

//     // Obtain the default prover.
//     let prover = default_prover();

//     // Proof information by proving the specified ELF binary.
//     // This struct contains the receipt along with statistics about execution of the guest
//     let prove_info = prover
//         .prove(env, HELLO_GUEST_ELF)
//         .unwrap();

//     // extract the receipt.
//     let receipt = prove_info.receipt;

//     // TODO: Implement code for retrieving receipt journal here.

//     // For example:
//     let _output: u32 = receipt.journal.decode().unwrap();

//     println!("Hello, world! I generated a proof of guest execution! {} is a public output from journal ", _output);

//     // The receipt was verified at the end of proving, but the below code is an
//     // example of how someone else could verify this receipt.
//     receipt
//         .verify(HELLO_GUEST_ID)
//         .unwrap();
// }

fn load_file(file_path: &str) -> io::Result<Vec<u8>> {
    let mut file = File::open(file_path)?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer)?;
    Ok(buffer)
}

fn execute(file_path: &str){
    println!("start execute·····");
    let env = ExecutorEnv::builder()
        .build()
        .unwrap();

    let file_contents = match load_file(file_path) {
        Ok(contents) => contents,
        Err(e) => {
            eprintln!("Error loading file: {}", e);
            return;
        }
    };

    let mut exec = ExecutorImpl::from_elf(env, &file_contents).unwrap();
    let output=exec.run().unwrap();
    match output.journal {
        Some(journal) => {
            println!("original output: {:?}", journal);
            if !journal.bytes.is_empty() {
                let _output:String=journal.decode().unwrap();
                println!("decoded output: {:?}", _output);
            }
        }
        None => {
        }
    }
    println!("end execute·····");
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 3 {
        eprintln!("Usage: {} <file_path> <mode>", args[0]);
        std::process::exit(1);
    }
    let file_path = &args[1];
    let mode = &args[2];
    if mode=="execute"{
        execute(file_path)
    }
    else{
        // prove(file_path)
    }
    
    
}
